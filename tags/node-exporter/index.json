[{"content":"监控环境搭建 需要以下组件：\ndocker prometheus node-exporter cadvisor grafana docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 version: \u0026#34;3.3\u0026#34; networks: monitor: driver: bridge services: node-exporter: image: prom/node-exporter:latest container_name: \u0026#34;node-exporter0\u0026#34; ports: - \u0026#34;9130:9100\u0026#34; restart: always networks: - monitor cadvisor: image: google/cadvisor:latest container_name: \u0026#34;cadvisor0\u0026#34; restart: always volumes: - /:/rootfs:ro - /var/run:/var/run:rw - /sys:/sys:ro - /var/lib/docker/:/var/lib/docker:ro ports: - \u0026#34;8081:8080\u0026#34; networks: - monitor prometheus: image: prom/prometheus:latest container_name: \u0026#34;prometheus0\u0026#34; restart: always ports: - \u0026#34;9097:9090\u0026#34; volumes: - \u0026#34;./prometheus.yml:/etc/prometheus/prometheus.yml\u0026#34; - \u0026#34;./prometheus_data:/prometheus\u0026#34; networks: - monitor grafana: image: grafana/grafana container_name: \u0026#34;grafana0\u0026#34; ports: - \u0026#34;3005:3000\u0026#34; restart: always volumes: - \u0026#34;./grafana_data:/var/lib/grafana\u0026#34; - \u0026#34;./grafana_log:/var/log/grafana\u0026#34; - \u0026#34;./grafana_data/crypto_data:/crypto_data\u0026#34; networks: - monitor prometheus.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 global: scrape_interval: 15s # 默认抓取周期 external_labels: monitor: \u0026#39;codelab-monitor\u0026#39; scrape_configs: - job_name: \u0026#39;prometheus\u0026#39; static_configs: - targets: [\u0026#39;172.16.139.24:9097\u0026#39;, \u0026#39;172.16.139.24:8081\u0026#39;] - job_name: \u0026#39;node-exporter\u0026#39; #服务的名称 scrape_interval: 5s metrics_path: /metrics #获取指标的url static_configs: - targets: [\u0026#39;172.16.139.24:9130\u0026#39;] # 这个为监听指定服务服务的ip和port，需要修改为自己的ip,不能使用localhost和127.0.0.1 - job_name: \u0026#34;cadvisor\u0026#34; static_configs: - targets: - \u0026#39;172.16.139.24:8081\u0026#39; 启动 1 docker-compose up -d 结果如下：\n检查 浏览器访问\nnode-exporter http://172.16.139.24:9130/metrics\ncadvisor http://172.16.139.24:8081/containers/\nprometheus http://172.16.139.24:9097/targets\ngrafana http://172.16.139.24:3005/login\n用户名/密码 admin/admin\n操作：\n添加数据源\nConfiguration下\nAdd data source\nurl填上：http://172.16.139.24:9097\nSave \u0026amp; test\n导入面板\nid： 10619\nDocker Container \u0026amp; Host Metrics\n结果\n参考 https://grafana.com/grafana/dashboards/893-main/ https://www.jianshu.com/p/cb50ffe0b6b0 https://www.jianshu.com/p/bd64a114aab0 https://www.cnblogs.com/augus007/articles/9225431.html https://juejin.cn/post/6969764486701924383 https://blog.csdn.net/An1090239782/article/details/102999721 https://grafana.com/dashboards?search=docker https://www.gbmb.org/mib-to-mb ","description":"用grafana展示容器内存使用情况","id":0,"section":"posts","tags":["docker","grafana","cadvisor","prometheus","node-exporter"],"title":"监控机器上的docker容器","uri":"https://puzzledstorm.github.io/posts/monitor-docker-containers/"},{"content":"获取一个视频的所有帧 解码一个视频有多种方式，这里分别用pyav和opencv做示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 \u0026#34;\u0026#34;\u0026#34; decoder.py Destination: decode a video, get all frames Some documents： http://ffmpeg.org/documentation.html \u0026#34;\u0026#34;\u0026#34; import os import os.path as osp import shutil import time import uuid import av import cv2 class Decoder(object): def __init__(self): super(Decoder, self).__init__() @staticmethod def av_decoder(path_to_video, frame_dir=\u0026#34;frames/\u0026#34;): \u0026#34;\u0026#34;\u0026#34; PyAV document: https://pyav.org/docs/stable/index.html https://pyav.org/docs/stable/cookbook/numpy.html Returns: \u0026#34;\u0026#34;\u0026#34; # 解码获取视频帧并转换np数组 container = av.open(path_to_video) container.streams.video[0].thread_type = \u0026#34;AUTO\u0026#34; np_frames = [] for frame in container.decode(video=0): print(frame) array = frame.to_ndarray(format=\u0026#34;bgr24\u0026#34;) np_frames.append(array) container.close() print(len(np_frames)) print(np_frames[0].shape) return np_frames @staticmethod def cv2_decoder(path_to_video, frame_dir=\u0026#34;frames/\u0026#34;): \u0026#34;\u0026#34;\u0026#34; opencv-python document: https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_tutorials.html https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_gui/py_video_display/py_video_display.html Returns: \u0026#34;\u0026#34;\u0026#34; cap = cv2.VideoCapture(path_to_video) np_frames = [] while cap.isOpened(): ret, frame = cap.read() if not ret: break print(\u0026#39;read a new frame\u0026#39;) np_frames.append(frame) cap.release() print(len(np_frames)) print(np_frames[0].shape) return np_frames 编码所有帧 同样地分别用上述两种方法来做。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 \u0026#34;\u0026#34;\u0026#34; encoder.py Destination: encode a video, only with video stream Some documents： http://ffmpeg.org/documentation.html \u0026#34;\u0026#34;\u0026#34; import os import os.path as osp import shutil import time import cv2 import numpy as np import av import uuid from decoder import Decoder class Encoder(object): def __init__(self): super(Encoder, self).__init__() self.fps = 25 self.width = 1920 self.height = 1080 self.bit_rate = 8 * 1014 * 1024 def av_encoder(self, frames, encode_video): # 编码一个视频返回 container = av.open(encode_video, mode=\u0026#34;w\u0026#34;) stream = container.add_stream(\u0026#34;mpeg4\u0026#34;, rate=self.fps) container.streams.video[0].thread_type = \u0026#34;AUTO\u0026#34; stream.width = self.width stream.height = self.height stream.bit_rate = self.bit_rate stream.pix_fmt = \u0026#34;yuv420p\u0026#34; for frame in frames: frame = av.VideoFrame.from_ndarray(frame, format=\u0026#34;bgr24\u0026#34;) for packet in stream.encode(frame): container.mux(packet) # Flush stream for packet in stream.encode(): container.mux(packet) # Close the file container.close() print(f\u0026#34;{encode_video} encode complete\u0026#34;) def cv2_encoder(self, frames, encode_video): size = (self.width, self.height) fourcc = cv2.VideoWriter_fourcc(*\u0026#39;mp4v\u0026#39;) out = cv2.VideoWriter(encode_video, fourcc, self.fps, size) for frame in frames: out.write(frame) out.release() print(f\u0026#34;{encode_video} encode complete\u0026#34;) def av_set_parameter(self, video): with av.open(video) as container: stream = container.streams.video[0] self.fps = stream.codec_context.framerate # type :Fraction self.width = stream.codec_context.width self.height = stream.codec_context.height self.bit_rate = stream.bit_rate # video的码率 # all_bit_rate = container.bit_rate # 视频总码率 def cv2_set_parameter(self, video): cap = cv2.VideoCapture(video) self.fps = int(round(cap.get(cv2.CAP_PROP_FPS))) # 帧率 self.width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)) # 分辨率-宽度 self.height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)) # 分辨率-高度 # frame_counter = int(cap.get(cv2.CAP_PROP_FRAME_COUNT)) # 总帧数 # https://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html#videocapture-get # 2.4 can\u0026#39;t find bit rate # https://docs.opencv.org/5.x/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d # find it, but my opencv version can\u0026#39;t use it # self.bit_rate = int(cap.get(cv2.CAP_PROP_BITRATE)) cap.release() ","description":"如题所示","id":1,"section":"posts","tags":["encode"],"title":"How to encode a video by all frames","uri":"https://puzzledstorm.github.io/posts/how-to-encode-a-video-by-frames/"},{"content":"大概就是之前去了大熊猫繁殖基地，拍了几个视频。一直放在手机里太占内存了，而且我一直以来想学习一下剪辑，Pr或者达芬奇。\n这次终于有机会了，虽然主观意愿也不是很强烈。\n视频我没有太多剪辑，直接放到b站上了。\n","description":"学习一下如何用达芬奇把我拍的大熊猫视频剪出来","id":2,"section":"posts","tags":["达芬奇"],"title":"学习剪辑艺术","uri":"https://puzzledstorm.github.io/posts/davinci/"},{"content":"盯着这个页面发呆，真的不知道说点啥。\n说实话，以前我经常自我反思，思考的时间不能说很多，但是至少我有意识的在往思考的方向走。现在，连书都懒得看了。以前还天天刷知乎，现在整天刷着b站，看看搞笑鬼畜视频。\n有时候想想当个死肥宅也不错，看看纸片人也能开心，哪怕不及新垣结衣万分之一。\n多说无益，我打算不搞反思，要搞好玩开心的东西。\n","description":"Hugo, the world’s fastest framework for building websites","id":3,"section":"","tags":null,"title":"About","uri":"https://puzzledstorm.github.io/about/"}]